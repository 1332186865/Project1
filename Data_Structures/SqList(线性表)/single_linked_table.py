#  Copyright (c) 2022. Generated by Gu.
class LinkNode:
    """单链表结点类"""

    def __init__(self, data=None):
        self.data = data
        self.next = None


class LinkList:
    """单链表类"""

    def __init__(self):
        self.head = LinkNode()
        self.head.next = None

    # 插入结点：新.next = 后.next; 后.pext = 新
    # 删除结点：前.next = 前.next.next
    def create_list_f(self, a):
        """头插法：由数组a整体建立单链表"""
        for i in range(0, len(a)):  # 循环建立数据结点s
            s = LinkNode(a[i])  # 新建存放a[i]的结点s
            s.next = self.head.next  # 把s插入开始结点前，头结点之后
            self.head.next = s

    def create_list_r(self, a):
        """尾插法：由数组a整体建立单链表 O(n)"""
        t = self.head
        for i in range(0, len(a)):  # t始终指向尾结点，开始时指向头结点
            s = LinkNode(a[i])  # 新建存放a[i]的结点s
            t.next = s  # 把s插入t结点之后
            t = s
        t.next = None  # 将尾结点的next成员置空

    def geti(self, i):
        """返回序号为i的结点 O(n)"""
        p = self.head
        j = -1
        while j < i and p is not None:
            j += 1
            p = p.next
        return p

    def add(self, e):
        """单链表末尾添加元素e O(n)"""
        s = LinkNode(e)
        p = self.head
        while p.next is not None:  # 查找尾结点
            p = p.next
        p.next = s  # 插入

    def getsize(self):
        """返回长度 O(n)"""
        p = self.head
        cnt = 0
        while p.next is not None:  # 找到尾结点为止
            cnt += 1
            p = p.next
        return cnt

    def __getitem__(self, item):
        """序号item的元素 O(n)"""
        assert item >= 0
        p = self.geti(item)  # 查找序号item的结点p
        assert p is not None
        return p.data

    def __setitem__(self, key, value):
        """设置序号key的元素"""
        assert key >= 0
        p = self.geti(key)
        assert p is not None  # 查找序号key的结点p
        p.data = value

    def get_no(self, e):
        """查找第一个值为e的元素的序号"""
        j = 0
        p = self.head.next
        while p is not None and p.data != e:
            j += 1  # 查找元素e
            p = p.next
        if p is None:
            return -1
        else:
            return j

    def insert(self, i, e):
        """插入e作为第i个元素"""
        assert i >= 0
        s = LinkNode(e)
        p = self.geti(i - 1)  # 查找序号为i-1的结点p
        assert p is not None
        s.next = p.next  # 在p后插入s
        p.next = s

    def delete(self, i):
        """删除序号i位置的元素"""
        assert i >= 0
        p = self.geti(i - 1)  # 查找序号为i-1的结点p
        assert p is not None and p.next is not None
        p.next = p.next.next  # 删除p结点的后继结点

    def display(self):
        """输出单链表"""
        p = self.head.next
        while p is not None:
            print(p.data, end=' ')
            p = p.next
        print()

    def middle(self):
        """返回中间位置的数"""
        slow = self.head.next
        fast = self.head.next  # 均指向首结点
        while (fast and fast.next and fast.next.next) is not None:
            slow = slow.next  # 慢指针每次一个
            fast = fast.next.next  # 快指针每次两个
        return slow.data

    def maxcount(self):
        """若单链表存在多个值相同的结点，统计最大值结点的个数 O(n) O(1)"""
        cnt = 1
        p = self.head.next
        maxe = p.data  # 首结点值
        while p.next is not None:  # 循环到尾结点
            if maxe < p.next.data:
                maxe = p.next.data
                cnt = 1
            elif maxe == p.next.data:  # p为当前最大值结点
                cnt += 1
            p = p.next
        return cnt

    def delmaxnodes(self):
        """若单链表存在多个值相同的结点,删除所有的最大值结点"""
        p = self.head.data
        maxe = p.data
        while p.next is not None:  # 查找最大结点值maxe
            if p.next.data > maxe:
                maxe = p.next.data
            p = p.next
        pre = self.head  # 指向头结点
        p = pre.next  # 指向pre后继结点
        while p is not None:
            if p.data == maxe:
                pre.next = p.next  # 删除p结点
                p = pre.next  # 让p指向pre的后继结点
            else:
                pre = pre.next  # pre后移一个结点
                p = pre.next  # 让p指向pre的后继结点

    def reversed(self):
        """逆置 n, 1"""
        p = self.head.next
        self.head.next = None  # 置为空表
        while p is not None:
            q = p.next  # q临时保存p的后继结点
            p.next = self.head.next
            self.head.next = p
            p = q
        return self.display()

    def split(self, a, b):
        """将一个单链表的奇数与偶数位分别用尾插法与头插法拆成两个"""
        p = self.head.next
        t = a.head  # t始终指向a的尾结点
        while p is not None:
            t.next = p
            t = p  # 尾插法
            p = p.next
            if p is not None:
                q = p.next  # 临时保存p的后继结点
                p.next = b.head.next  # 头插法
                b.head.next = p
                p = q  # p指向q结点
        t.next = None
        return a.display(), b.display()

    def merge(self, b):
        """将两个递增有序整数单链表采用二路归并合并为新表 (m+n) 1"""
        p = self.head.next
        q = b.head.next
        c = LinkList()
        t = c.head  # c的尾结点
        while p is not None and q is not None:
            if p.data < q.data:  # 将较小结点添加到c的末尾
                t.next = p
                t = p
                p = p.next
            else:
                t.next = q
                t = q
                q = q.next
        t.next = None  # 尾结点next置空
        if p is not None:
            t.next = p
        if q is not None:
            t.next = q
        return c

    def commnode(self, b):
        """两个递增有序整数单链表,每一个中无重复,两个中有重复，不改变原有基础上创建新表，
        包含值相等的结点。采用二路归并+尾插法构建新表"""
        p = self.head.next
        q = b.head.next
        c = LinkList()
        t = c.head
        while p is not None and q is not None:
            if p.data < q.data:  # 跳过较小的p结点
                p = p.next
            elif q.data < p.data:  # 跳过较小的q结点
                q = q.next
            else:  # p，q值相同
                s = LinkNode(p.data)
                t.next = s  # 将s链接到c末尾
                t = s
                p = p.next
                q = q.next
        t.next = None  # 尾结点置空
        return c


a1 = LinkList()
x = LinkList()
y = LinkList()
a1.create_list_r([1, 2, 3, 4, 5, 6])
a1.display()
# print(a1.__getitem__(3))
a1.reversed()
# a1.split(x, y)
