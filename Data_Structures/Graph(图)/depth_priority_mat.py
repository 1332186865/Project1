#  Copyright (c) 2022. Generated by Gu.
# 不限定图的实现方式，在图结构上，编程实现深度优先遍历。
import copy

INF = 0x3f3f3f3f
MAXV = 100
visited = [0] * MAXV


class MatGraph:  # 无穷  ? O(n^2)
    """图邻接矩阵类"""

    def __init__(self, n=0, e=0):
        self.edges = []  # 邻接矩阵数组
        self.vexs = []  # vexs[i]存放顶点i的信息，暂时未用
        self.n = n  # 顶点数
        self.e = e  # 边数

    def create_mat_graph(self, a, n, e):
        """通过数组a，顶点n与边数e建立的图的邻接矩阵"""
        self.n = n
        self.e = e
        self.edges = copy.deepcopy(a)

    def disp_mat_graphs(self):
        """输出图的邻接矩阵数组"""
        for i in range(self.n):
            for j in range(self.n):
                if self.edges[i][j] == INF:
                    print("%4s" % "∞", end=' ')
                else:
                    print("%5d" % (self.edges[i][j]), end=' ')
            print()

    def dfs(self, v):
        print(v, end=' ')
        visited[v] = 1
        for w in range(self.n):
            if self.edges[v][w] != 0 and self.edges[v][w] != INF:
                if visited[w] == 0:
                    self.dfs(w)


mat = [
    [0, 1, 1, 0, 0, 0],
    [0, 0, 0, 0, 0, 1],
    [0, 0, 0, 1, 1, 1],
    [0, 0, 0, 0, 0, 0],
    [0, 0, 0, 1, 0, 0],
    [0, 0, 0, 0, 0, 0]
    ]
mat1 = MatGraph()
mat1.create_mat_graph(mat, 6, 7)
mat1.disp_mat_graphs()
mat1.dfs(0)
