# Copyright (c) 2022. Generated by Gu.
import copy
from collections import deque

INF = 0x3f3f3f3f
MAXV = 100
visited = [0] * MAXV


class MatGraph:  # ? O(n^2)
    """图邻接矩阵类"""

    def __init__(self, n=0, e=0):
        self.edges = []  # 邻接矩阵数组
        self.vexs = []  # vexs[i]存放顶点i的信息，暂时未用
        self.n = n  # 顶点数
        self.e = e  # 边数

    def create_mat_graph(self, a, n, e):
        """通过数组a，顶点n与边数e建立的图的邻接矩阵"""
        self.n = n
        self.e = e
        self.edges = copy.deepcopy(a)

    def disp_mat_graphs(self):
        """输出图的邻接矩阵数组"""
        for i in range(self.n):
            for j in range(self.n):
                if self.edges[i][j] == INF:
                    print("%4s" % "∞", end=' ')
                else:
                    print("%5d" % (self.edges[i][j]), end=' ')
            print()

    def bfs(self, v):
        """在邻接矩阵中从顶点v出发的广度优先遍历 (n^2)"""
        qu = deque()  # 将双端队列作为普通队列qu
        print(v, end=' ')  # 访问顶点v
        visited[v] = 1  # 置已访问标记
        qu.append(v)  # v进队
        while len(qu) > 0:  # 队不空时循环
            v = qu.popleft()  # 出队顶点v
            for w in range(self.n):
                if self.edges[v][w] != 0 and self.edges[v][w] != INF:
                    if visited[w] == 0:  # 存在<v ,w>并且w未被访问
                        print(w, end=' ')  # 访问顶点w
                        visited[w] = 1  # 置已访问标记
                        qu.append(w)  # w进队


mat = [
    [0, 1, 1, 0, 0, 0],
    [0, 0, 0, 0, 0, 1],
    [0, 0, 0, 1, 1, 1],
    [0, 0, 0, 0, 0, 0],
    [0, 0, 0, 1, 0, 0],
    [0, 0, 0, 0, 0, 0]
    ]
mat1 = MatGraph()
mat1.create_mat_graph(mat, 6, 7)
mat1.disp_mat_graphs()
mat1.bfs(0)
