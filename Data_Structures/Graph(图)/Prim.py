#  Copyright (c) 2022. Generated by Gu.
import copy

INF = 0x3f3f3f3f
MAXV = 100


class MatGraph:
    """图邻接矩阵类"""

    def __init__(self, n=0, e=0):
        self.edges = []  # 邻接矩阵数组
        self.vexs = []  # vexs[i]存放顶点i的信息，暂时未用
        self.n = n  # 顶点数
        self.e = e  # 边数

    def create_mat_graph(self, a, n, e):
        """通过数组a，顶点n与边数e建立的图的邻接矩阵"""
        self.n = n
        self.e = e
        self.edges = copy.deepcopy(a)

    def disp_mat_graphs(self):
        """输出图的邻接矩阵数组"""
        for i in range(self.n):
            for j in range(self.n):
                if self.edges[i][j] == INF:
                    print("%5s" % "∞", end=' ')
                else:
                    print("%5d" % (self.edges[i][j]), end=' ')
            print()


def Prim(g, v):  # 求最小生成树
    lowcost = [0] * MAXV  # 建立数组lowcost
    closest = [0] * MAXV  # 建立数组closest
    for i in range(g.n):  # 给lowcost[]和closest[]置初值
        lowcost[i] = g.edges[v][i]
        closest[i] = v
    for i in range(1, g.n):  # 找出最小生成树的n-1条边
        min = INF
        k = -1
        for j in range(g.n):  # 在(V-U)中找出离U最近的顶点k
            if lowcost[j] != 0 and lowcost[j] < min:
                min = lowcost[j]
                k = j  # k记录最小顶点的编号
        print("(%d,%d):%d" % (closest[k], k, +min), end=' ')  # 输出最小生成树的边
        lowcost[k] = 0  # 将顶点k加入U中
        for j in range(g.n):  # 修改数组lowcost和closest
            if lowcost[j] != 0 and g.edges[k][j] < lowcost[j]:
                lowcost[j] = g.edges[k][j]
                closest[j] = k


g = MatGraph()
n, e = 7, 11
a = [[0, 5, 9, INF, INF, INF, INF],
     [5, 0, 7, INF, 14, 6, INF],
     [9, 7, 0, 3, 10, INF, INF],
     [INF, INF, 3, 0, 11, INF, INF],
     [INF, 14, 10, 11, 0, 10, 9],
     [INF, 6, INF, INF, 10, 0, 11],
     [INF, INF, INF, INF, 9, 11, 0]]
g.create_mat_graph(a, n, e)
g.disp_mat_graphs()
Prim(g, 0)
