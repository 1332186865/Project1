#  Copyright (c) 2022. Generated by Gu.
# 在图结构上，编程实现广度优先遍历。
from collections import deque

INF = 0x3f3f3f3f
MAXV = 100  # 全局变量,表示最多顶点个数
visited = [0] * MAXV


class ArcNode:
    """边结点"""

    def __init__(self, adjv, w):
        self.adjvex = adjv  # 邻接点
        self.weight = w  # 边的权值

    def __repr__(self):
        return "[%s, %s]" % (self.adjvex, self.weight)


class AdjGraph:
    """图邻接表法, 稀疏图节约空间"""

    def __init__(self, n=0, e=0):
        self.adjlist = []  # 邻接表数组
        self.vexs = []  # vexs[i]存放顶点i的信息， 暂时未用
        self.n = n  # 顶点数
        self.e = e  # 边数

    def create_adj_graph(self, a, n, e):
        """通过数组a,顶点数n, 边数e建立图的邻接表"""
        self.n = n
        self.e = e
        for i in range(n):  # 检查边数组a中的每一个元素
            adi = []  # 顶点i的邻接点， 初始为空
            for j in range(n):
                if a[i][j] != 0 and a[i][j] != INF:  # 存在一条边
                    p = ArcNode(j, a[i][j])  # 创建<j, a[i][j]>出边的结点p
                    adi.append(p)  # 将结点p添加到adi中
            self.adjlist.append(adi)

    def dsip_adj_graph(self):
        """输出图的邻接表"""
        for i in range(self.n):  # 遍历每一个顶点i
            print(" [%d]" % i, end='')
            for p in self.adjlist[i]:
                print("->(%d. %d)" % (p.adjvex, p.weight), end='')
            print("->")

    def bfs(self, v):
        """在邻接表G中从顶点v出发的广度优先遍历 (n+e)"""
        qu = deque()  # 将双端队列作为普通队列qu
        print(v, end=' ')  # 访问顶点v
        visited[v] = 1  # 置已访问标记
        qu.append(v)  # v进队
        while len(qu) > 0:  # 队不空时循环
            v = qu.popleft()  # 出队顶点v
            for j in range(len(self.adjlist[v])):  # 处理顶点v的所有出边
                w = self.adjlist[v][j].adjvex  # 取顶点v的第j个出边邻接点w
                if visited[w] == 0:  # 若w未被访问
                    print(w, end=' ')  # 访问顶点w
                    visited[w] = 1  # 置已访问标记
                    qu.append(w)  # w进队


adj = [
    [0, 1, 1, 0, 0, 0],
    [0, 0, 0, 0, 0, 1],
    [0, 0, 0, 1, 1, 1],
    [0, 0, 0, 0, 0, 0],
    [0, 0, 0, 1, 0, 0],
    [0, 0, 0, 0, 0, 0]
    ]
adj1 = AdjGraph()
adj1.create_adj_graph(adj, 6, 7)
adj1.dsip_adj_graph()
adj1.bfs(0)
