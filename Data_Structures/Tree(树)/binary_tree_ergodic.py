#  Copyright (c) 2022. Generated by Gu.
#  -*- coding=utf-8 -*-
class BTNode:
    def __init__(self, d=None):
        self.data = d
        self.lchild = None
        self.rchild = None


class BTree(BTNode):
    def __init__(self, d=None):
        super().__init__(d)
        self.b = None

    def setroot(self, r):  # 设置根节点为r
        self.b = r


def pre_order(bt):  # 先序遍历的递归算法
    _pre_order(bt.b)


def _pre_order(t):  # 被PreOrder()方法调用
    if t is not None:
        print(t.data, end='')  # 访问根结点
        _pre_order(t.lchild)  # 先序遍历左子树
        _pre_order(t.rchild)  # 先序遍历右子树


def in_order(bt):  # 中序遍历的递归算法
    _in_order(bt.b)


def _in_order(t):
    if t is not None:
        _in_order(t.lchild)
        print(t.data, end='')
        _in_order(t.rchild)


def post_order(bt):
    _post_order(bt.b)


def _post_order(t):  # 后序遍历的递归算法
    if t is not None:
        _post_order(t.lchild)
        _post_order(t.rchild)
        print(t.data, end='')


def post_order2(bt):
    _post_order2(bt.b)


def _post_order2(t):
    if t is None:
        return
    # 定义两个栈
    stack1 = []
    stack2 = []
    # 将结点加入第一个栈中
    stack1.append(t)
    # 第一个栈不为空
    while stack1:
        t = stack1.pop()
        if t.lchild is not None:
            stack1.append(t.lchild)
        if t.rchild is not None:
            stack1.append(t.rchild)
        stack2.append(t)
    while stack2:
        d = stack2.pop()
        print(d.data, end='')


b1 = BTree('A')  # 建立各个结点
p1 = BTree('B')
p2 = BTree('C')
p3 = BTree('D')
p4 = BTree('E')
p5 = BTree('F')
p6 = BTree('G')
b1.lchild = p1  # 建立结点间的关系
b1.rchild = p2
p1.lchild = p3
p3.rchild = p6
p2.lchild = p4
p2.rchild = p5
b1.setroot(b1)

# pre_order(b1)
# print()
# in_order(b1)
# print()
# post_order(b1)
# print()
post_order2(b1)
