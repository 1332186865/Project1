#  Copyright (c) 2022. Generated by Gu.
#  -*- coding=utf-8 -*-

# 双亲存储结构: 顺序存储结构[结点值，双亲结点索引] 求双亲结点容易，求孩子节点要遍历
t = [['A', -1], ['B', 0], ['C', 0], ['D', 1], ['E', 1], ['F', 1], ['G', 4]]


# 求指定索引为i的结点的层次
def level(t, i):
    assert 0 <= i < len(t)
    cnt = 1
    while t[i][1] != -1:
        cnt += 1
        i = t[i][1]
    return cnt


# 孩子链存储结构 每个结点包含数据值和指向所有孩子节点的指针
class SonNode:
    def __init__(self, d=None):
        self.data = d
        self.sons = []


def height1(t):  # 求t的高度
    if len(t.sons) == 0:
        return 1
    maxsh = 0
    for i in range(len(t.sons)):
        sh = height1(t.sons[i])  # 求子树t.sons[i]的高度
        maxsh = max(maxsh, sh)  # 求所有子树的最大高度
    return maxsh + 1


# 长子兄弟链存储结构 数据元素属性，指向改结点长子的指针，指向下一个兄弟结点的指针
class EBNode:
    def __init__(self, d=None):
        self.data = d
        self.brother = None
        self.eson = None


def height2(t):
    if t is None:
        return 0
    maxsh = 0
    p = t.eson  # p指向t结点的长子
    while p is not None:
        q = p.brother  # q临时保存p的后继结点
        sh = height2(p)  # 递归求p子树的高度
        maxsh = max(maxsh, sh)  # 求t所有子树的最大高度
        p = q
    return maxsh + 1


# 列表存储结构
t = ['A', ['B', ['D'], ['E', ['G']], ['F']], ['C']]


def height3(t):
    if len(t) == 1:
        return 1
    m = len(t)
    maxsh = 0
    for i in range(1, m):
        sh = height3(t[i])
        maxsh = max(maxsh, sh)
    return maxsh + 1
