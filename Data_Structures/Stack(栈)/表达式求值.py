#  Copyright (c) 2022. Generated by Gu.
#  -*- coding=utf-8 -*-
# 栈的综合应用 P103
from SqStack import SqStack


class ExpressClass:
    """求表达式值的类"""

    def __init__(self, str1):
        self.exp = str1
        self.postexp = []

    def get_postexp(self):
        """返回postexp"""
        return self.postexp

    def trans(self):
        """将exp转化为postexp（中缀=>后缀）"""
        opor = SqStack()  # 定义运算符栈
        i = 0  # i为索引
        while i < len(self.exp):  # 遍历
            ch = self.exp[i]  # 提取str[i]字符ch
            if ch == '(':  # 左括号判断
                opor.push(ch)
            elif ch == ')':  # 右括号判断
                while not opor.empty() and opor.get_top() != '(':
                    e = opor.pop()  # 栈中最近的（ 前的运算符退栈
                    self.postexp.append(e)  # 退栈运算符添加到postexp
                opor.pop()  # 将（ 退栈
            elif ch == '+' or ch == "-":  # 判断+或-
                while not opor.empty() and opor.get_top() != '(':
                    e = opor.pop()  # 将栈中不低于ch优先级的所有运算符退栈
                    self.postexp.append(e)  # 退栈运算符添加到postexp
                opor.push(ch)  # 将+或-进栈
            elif ch == '*' or ch == "/":  # 判断*或/
                while not opor.empty():
                    e = opor.get_top()
                    if e != "(" and (e == "*" or e == "/"):
                        e = opor.pop()  # 将栈中不低于ch优先级的所有运算符退栈
                        self.postexp.append(e)  # 退栈运算符添加到postexp
                    else:
                        break
                opor.push(ch)  # 将*或/进栈
            else:  # 处理数字字符
                d = ""
                while "0" <= ch <= "9":  # 判断为数字
                    d += ch
                    i += 1
                    if i < len(self.exp):
                        ch = self.exp[i]
                    else:
                        break
                i -= 1  # 退一个字符
                self.postexp.append(int(d))  # 将连续的数字字符转化为整数并添加到postexp
            i += 1  # 继续处理
        while not opor.empty():  # 栈不空时循环
            e = opor.pop()  # 栈中所有运算符退栈并添加到postexp
            self.postexp.append(e)

    def get_value(self):
        opand = SqStack()  # 定义运算数栈
        i = 0
        while i < len(self.postexp):  # 遍历postexp
            opv = self.postexp[i]  # 从后缀表达式取一个元素opv
            if opv == "+":
                a = opand.pop()  # 退栈取运算数a
                b = opand.pop()  # 退栈取运算数b
                c = b + a
                opand.push(c)  # 将计算结果退栈
            elif opv == "-":
                a = opand.pop()
                b = opand.pop()
                c = b - a
                opand.push(c)
            elif opv == "*":
                a = opand.pop()
                b = opand.pop()
                c = b * a
                opand.push(c)
            elif opv == "/":
                a = opand.pop()
                b = opand.pop()
                assert a != 0  # 检测a = 0情况
                c = b / a  # 整除要改为//
                opand.push(c)
            else:  # 处理运算数
                opand.push(opv)  # 将运算数opv进栈
            i += 1  # 继续处理postexp其他元素
        return opand.get_top()  # 栈顶元素即为求值结果


if __name__ == '__main__':
    try:
        str = "1+5/(1-1)"
        obj = ExpressClass(str)
        obj.trans()
        print("express:", obj.get_postexp())
        print("results: %g" % (obj.get_value()))
    except AssertionError:
        print('ILLEGAL')
    print('------')
    str = '(56-20)/(4+2)'
    print('中缀表达式' + str)
    obj = ExpressClass(str)
    obj.trans()
    print('后缀表达式', obj.get_postexp())
    print('结果: %g' % obj.get_value())
