#  Copyright (c) 2022. Generated by Gu.
#  -*- coding=utf-8 -*-
# 栈的综合应用 P108
from SqStack import SqStack

mg = [[1, 1, 1, 1, 1, 1],
      [1, 0, 1, 0, 0, 1],
      [1, 0, 0, 1, 1, 1],
      [1, 0, 1, 0, 0, 1],
      [1, 0, 0, 0, 0, 1],
      [1, 1, 1, 1, 1, 1]]


class Box:
    """方块类"""

    def __init__(self, i1, j1, di1):
        self.i = i1  # 行号
        self.j = j1  # 列号
        self.di = di1  # di是可走相邻方位的方位号


def mgpath(xi, yi, xe, ye):
    """(xi, yi)->(xe, ye)的迷宫路径"""
    global mg  # 迷宫数组
    st = SqStack()
    dx = [-1, 0, 1, 0]  # x方向偏移量
    dy = [0, 1, 0, -1]  # y方向偏移量
    e = Box(xi, yi, -1)  # 入口方块对象
    st.push(e)  # 入口方块进栈
    mg[xi][yi] = -1  # 进栈方块置为-1
    while not st.empty():
        b = st.get_top()  # 当前方块
        if b.i == xe and b.j == ye:  # 找到出口输出路径
            for k in range(len(st.data)):
                print("[" + str(st.data[k].i) + ',' + str(st.data[k].j) + "]", end='')
            return True  # 找到路径
        find = False
        di = b.di
        while di < 3 and not find:  # 找b的一个相邻可走方块
            di += 1  # 下一个方位的相邻方块
            i, j = b.i + dx[di], b.j + dy[di]  # b的di方向相邻方块(i, j)
            if not mg[i][j]:  # (i, j)方块可走
                find = True
        if find:
            b.di = di
            b1 = Box(i, j, -1)
            st.push(b1)
            mg[i][j] = -1
        else:
            mg[b.i][b.j] = 0  # 恢复当前方块迷宫值
            st.pop()
    return False  # 没有找到迷宫路径


if __name__ == '__main__':
    xi, yi = 1, 1
    xe, ye = 4, 4
    print('路径:', end=' ')
    if not mgpath(xi, yi, xe, ye):
        print('不存在路径！')
