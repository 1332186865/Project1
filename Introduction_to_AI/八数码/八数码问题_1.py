#  Copyright (c) 2022. Generated by Gu.
#  -*- coding=utf-8 -*-
import operator
import numpy as np


class State:
    """状态类"""

    def __init__(self, m):
        self.node = m  # 节点代表的状态
        self.f = 0  # f(n)=g(n)+h(n)
        self.g = 0  # g(n)
        self.h = 0  # h(n)
        self.father = None  # 节点的父亲节点


class Solution:
    def __init__(self, matrix_origin: list, matrix_target: list):
        """
        :param matrix_origin: 初始矩阵
        :param matrix_target: 目标矩阵
        """
        self.matrix = np.array(matrix_origin)
        self.target = np.array(matrix_target)
        self.status = False  # 记录是否找到目标状态
        self.init = State(self.matrix)  # 初始状态
        self.goal = State(self.target)  # 目标状态
        self.open_list = []  # open表

    def h(self, s):
        """启发函数"""
        a = 0
        for i in range(len(s.node)):
            for j in range(len(s.node[i])):
                if s.node[i][j] != self.goal.node[i][j]:
                    a = a + 1
        return a

    @staticmethod
    def list_sort(lst):
        """对节点列表按照估价函数的值的规则排序"""
        lst.sort(key=operator.attrgetter('f'))

    def a_star(self, s):
        """A*算法"""
        self.open_list = [s]
        while self.open_list:  # 当open表不为空
            get = self.open_list[0]  # 取出open表的首节点
            if (get.node == self.goal.node).all():  # 判断是否与目标节点一致
                return get
            self.open_list.remove(get)  # 将get移出open表
            # 判断此时状态的空格位置
            for a in range(len(get.node)):
                for b in range(len(get.node[a])):
                    if get.node[a][b] == 0:
                        break
                if get.node[a][b] == 0:
                    break
            # 开始移动
            for i in range(len(get.node)):
                for j in range(len(get.node[i])):
                    c = get.node.copy()
                    if (i + j - a - b) ** 2 == 1:
                        c[a][b] = c[i][j]
                        c[i][j] = 0
                        new = State(c)
                        new.father = get  # 此时取出的get节点成为新节点的父亲节点
                        new.g = get.g + 1  # 新节点与父亲节点的距离
                        new.h = self.h(new)  # 新节点的启发函数值
                        new.f = new.g + new.h  # 新节点的估价函数值
                        self.open_list.append(new)  # 加入open表中
        self.list_sort(self.open_list)  # 排序

    def print_path(self, f):
        """递归打印路径"""
        if f is None:
            return
        # 注意print()语句放在递归调用前和递归调用后的区别。放在后实现了倒叙输出
        self.print_path(f.father)
        print(f.node, end='\n\n')

    def main(self):
        """主函数"""
        final = self.a_star(self.init)
        if final:
            print("有解，解为：")
            self.print_path(final)
        else:
            print("无解")


if __name__ == '__main__':
    start = [[0, 2, 3], [1, 8, 4], [7, 6, 5]]
    target = [[1, 2, 3], [8, 0, 4], [7, 6, 5]]
    Solution(start, target).main()
