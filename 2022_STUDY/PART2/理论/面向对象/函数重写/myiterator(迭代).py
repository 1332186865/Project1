#  Copyright (c) 2022. Generated by Gu.
class MyList:
    """定义一个容器类,用于存储任意类型的数据
    其内部的存储方式用list实现现"""

    def __init__(self, iterable):
        self.data = [y for y in iterable]

    def __repr__(self):
        return 'MyList(%s)' % self.data

    def __iter__(self):
        # """此方法可将MyList作为可迭代对象使用，此方法需要返回迭代器"""
        # return MyListIterator(self.data)  # 可迭代对象

        self.cur_pos = 0
        return self

    # 没有MyListIterator类时的操作
    def __next__(self):
        """此方法用来访问可迭代对象的数据, 如果没有数据时触发StopIterator异常来通知调用者停止迭代,即'迭代器协议'"""
        if self.cur_pos >= len(self.data):
            raise StopIteration  # 判断是否越界
        index = self.cur_pos
        self.cur_pos += 1  # 将当前位置向后移动准备下次获取
        return self.data[index]  # 返回当位置的数据
        # 此时既为可迭代对象又为迭代器


# class MyListIterator:
#     """此类定义一个迭代器类，用于生成能够访问MyList对象的
#     迭代器"""
#
#     def __init__(self, lst_data):
#         print("迭代器已调用")
#         self.data = lst_data
#         self.cur_pos = 0
#
#     def __next__(self):
#         """此方法用来访问可迭代对象的数据, 如果没有
#         数据时触发StopIterator异常来通知调用者停止迭代,
#         即'迭代器协议'"""
#         if self.cur_pos >= len(self.data):
#             raise StopIteration  # 判断是否越界
#         index = self.cur_pos
#         self.cur_pos += 1  # 将当前位置向后移动准备下次获取
#         return self.data[index]  # 返回当位置的数据


myl = MyList([1, -2, 3, -4])
# for x in myl:
#     print(x)
it = iter(myl)
while True:
    try:
        x = next(it)
        print(x)
    except StopIteration:
        break
