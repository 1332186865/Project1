#  Copyright (c) 2022. Generated by Gu.
#  -*- coding=utf-8 -*-
"""
    逻辑处理模块
"""
import copy
import random

from GamrCoreModel import Location, Direction


class GameCoreController:
    def __init__(self):
        # self.__matrix = [[2, 4, 2, 4], [4, 2, 4, 2], [2, 4, 2, 4], [0, 2, 0, 0]]
        self.__matrix = [[0] * 4,
                         [0] * 4,
                         [0] * 4,
                         [0] * 4]
        # Lists for de-zeroing and merging
        self.__list_merge = []
        # List for storing empty positions
        self.__list_empty_location = []
        #
        self.is_change = False

    @property
    def matrix(self):
        return self.__matrix

    def zero_to_end(self):
        """
        将0移到右边

        :return: 排序后的列表
        """
        for item in self.__list_merge:
            if not item:
                self.__list_merge.remove(item)
                self.__list_merge.append(0)

    def merge(self):
        """
        合并

        :return: 合并后的列表
        """
        self.zero_to_end()
        for i in range(len(self.__list_merge) - 1):
            if self.__list_merge[i] == self.__list_merge[i + 1]:
                self.__list_merge[i] += self.__list_merge[i + 1]
                self.__list_merge[i + 1] = 0
        self.zero_to_end()

    def display(self):
        """
        输出

        :return: 输出
        """
        for i in range(len(self.__matrix)):
            for j in range(len(self.__matrix[i])):
                print(self.__matrix[i][j], end='\t')
            print()

    def __move_left(self):
        """
            左移

        :return: None
        """
        for i in range(len(self.__matrix)):
            self.__list_merge[:] = self.__matrix[i]
            self.merge()
            self.__matrix[i][:] = self.__list_merge

    def __move_right(self):
        """
            右移

        :return: None
        """
        for i in range(len(self.__matrix)):
            self.__list_merge[:] = self.__matrix[i][::-1]
            self.merge()
            self.__matrix[i][::-1] = self.__list_merge

    def __move_up(self):
        """
            上移

        :return: None
        """
        for i in range(len(self.__matrix)):
            self.__list_merge[:] = [j[i] for j in self.__matrix]
            self.merge()
            for j in range(len(self.__matrix)):
                self.__matrix[j][i] = self.__list_merge[j]

    def __move_down(self):
        """
        下移

        :return:None
        """
        for i in range(len(self.__matrix)):
            self.__list_merge[:] = [j[i] for j in self.__matrix[::-1]]
            self.merge()
            self.__list_merge = self.__list_merge[::-1]
            for j in range(len(self.__matrix) - 1, -1, -1):
                self.__matrix[j][i] = self.__list_merge[j]

    def move(self, direction: Direction):
        """
        move

        :param direction: Direction class
        :return: None
        """
        # record the matrix before moving
        original_matrix = copy.deepcopy(self.__matrix)
        if direction == Direction.up:
            self.__move_up()
        elif direction == Direction.down:
            self.__move_down()
        elif direction == Direction.left:
            self.__move_left()
        elif direction == Direction.right:
            self.__move_right()
        # compare the matrix after moving
        self.is_change = original_matrix != self.__matrix

    def __calculate_empty_location(self):
        self.__list_empty_location[:] = [Location(r, c) for r in range(4)
                                         for c in range(4)
                                         if self.__matrix[r][c] == 0]

    def generate_new_number(self):
        """
            Generate new numbers at random and store them in the list

        :return: None
        """
        self.__calculate_empty_location()
        if len(self.__list_empty_location) == 0:
            return 0
        # Randomly select an element from a list of empty positions
        loc = random.choice(self.__list_empty_location)
        # Generate a random number
        self.__matrix[loc.r_index][loc.c_index] = 4 if random.randint(1, 10) <= 2 else 2
        self.__list_empty_location.remove(loc)

    def is_game_over(self):
        """
            Determine the end of the game

        :return: None
        """
        # If there is an empty position, the game cannot end
        if len(self.__list_empty_location) > 0:
            return False
        # Horizontal has the same element, the game cannot end
        # for r in range(4):
        #     for c in range(3):
        #         if self.__matrix[r][c] == self.__matrix[r][c + 1]:
        #             return False
        # If there are the same elements in the vertical direction, the game cannot end
        # for r in range(3):
        #     for c in range(4):
        #         if self.__matrix[r][c] == self.__matrix[r + 1][c]:
        #             return False
        # If there are the same elements in any direction, the game cannot end
        for r in range(4):
            for c in range(3):
                if self.__matrix[r][c] == self.__matrix[r][c + 1] or \
                        self.__matrix[c][r] == self.__matrix[c + 1][r]:
                    return False
        return True


if __name__ == '__main__':
    core = GameCoreController()
    core.display()
    core.generate_new_number()
    core.display()
    core.generate_new_number()
    core.display()
